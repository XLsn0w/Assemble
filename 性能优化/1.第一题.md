## 1.如何提升 `tableview` 的流畅度？


本质上是降低 CPU、GPU 的工作，从这两个大的方面去提升性能。

- CPU：对象的创建和销毁、对象属性的调整、布局计算、文本的计算和排版、图片的格式转换和解码、图像的绘制
- GPU：纹理的渲染


#### 卡顿优化在 CPU 层面
* 尽量用轻量级的对象，比如用不到事件处理的地方，可以考虑使用 CALayer 取代 UIView
* 不要频繁地调用 UIView 的相关属性，比如 frame、bounds、transform 等属性，尽量减少不必要的修改
* 尽量提前计算好布局，在有需要时一次性调整对应的属性，不要多次修改属性
* Autolayout 会比直接设置 frame 消耗更多的 CPU 资源
* 图片的 size 最好刚好跟 UIImageView 的 size 保持一致
* 控制一下线程的最大并发数量
* 尽量把耗时的操作放到子线程
    * 文本处理（尺寸计算、绘制）
    * 图片处理（解码、绘制）
    
    
#### 卡顿优化在 GPU层面

* 尽量避免短时间内大量图片的显示，尽可能将多张图片合成一张进行显示
* GPU能处理的最大纹理尺寸是 4096x4096，一旦超过这个尺寸，就会占用 CPU 资源进行处理，所以纹理尽量不要超过这个尺寸
* 尽量减少视图数量和层次
* 减少透明的视图（alpha<1），不透明的就设置 opaque 为 YES
* 尽量避免出现离屏渲染

[iOS 保持界面流畅的技巧](https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/)


##### 1.预排版，提前计算
在接收到服务端返回的数据后，尽量将 `CoreText` 排版的结果、单个控件的高度、`cell` 整体的高度提前计算好，将其存储在模型的属性中。需要使用时，直接从模型中往外取，避免了计算的过程。

尽量少用 `UILabel`，可以使用 `CALayer` 。避免使用 `AutoLayout` 的自动布局技术，采取纯代码的方式 

##### 2.预渲染，提前绘制

例如圆形的图标可以提前在，在接收到网络返回数据时，在后台线程进行处理，直接存储在模型数据里，回到主线程后直接调用就可以了

避免使用 CALayer 的 Border、corner、shadow、mask 等技术，这些都会触发离屏渲染。

##### 3.异步绘制


##### 4.全局并发线程

##### 5.高效的图片异步加载

